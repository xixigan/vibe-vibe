---
title: "第一章：环境搭建、代码形态与包管理器的选择"
---


![01-environment-setup_index.png](../../public/images/Advanced/01-environment-setup_index.png)
# 第一章：环境搭建、代码形态与包管理器的选择

## 序言

你有一台新电脑，里面干干净净，除了浏览器什么都没有。你不会写代码，但是你觉得最近 AI 很火，心里有一个绝妙的 App 想法，打算在网页上指挥 AI 帮你做一个 Demo。

### 代码格式

你遇到的第一个困惑是 **AI 输出代码的格式**。有时候，AI 会直接给你一段长长的代码，告诉你保存为 `index.html`。你照做了，新建文件、粘贴、保存，双击打开，浏览器里真的出现了一个会动的网页。你很高兴，以为编程不过如此。这种文件通常把结构（HTML）、样式（CSS）和逻辑（JavaScript）都塞在了一起，适合做简单的演示。

但当你要求更复杂的功能时，AI 开始给你后缀是 `.ts` 或 `.tsx` 的代码，还提到了 `import`、`React` 等词汇。你像之前一样保存文件，双击打开，却发现根本打不开，或者显示一堆看不懂的代码。你懵了，为什么代码不能跑了？

你不解地问："既然 AI 都能帮我写代码了，为什么还要学这些？"

老师傅说："AI 能写代码，但'怎么让它跑起来'需要你理解。这就像导航：能告诉你路线，但你得先会开车。环境搭建不是门槛，而是你与 AI 协作的第一步。"

### TypeScript 与 Node.js

老师傅告诉你，这是因为现代开发使用了 **TypeScript**（简称 TS），它比普通的 JavaScript 更严谨，适合做大项目。但是，浏览器看不懂 TS，它需要一个"翻译官"把 TS 翻译成浏览器能懂的语言。这个翻译官运行在你的电脑上，它的名字叫 **Node.js**。如果不安装它，你的电脑就无法运行这些现代化的代码构建工具。

### nvm 版本管理

你兴致勃勃地去下载 Node.js，但老师傅和 Nodejs 官网一样，拦住了你。他推荐你安装 **nvm**（Node Version Manager）。因为 Node.js 经常更新，不同项目可能需要不同版本，nvm 让你能轻松切换版本，而不需要反复卸载重装。你通过 nvm 安装了最新的 LTS（长期支持）版本，并在老师傅的推荐下更换了**国内镜像源**（为了解决下载慢的问题），终于拥有了所谓的运行环境。

### Terminal 终端

接着，你接触到了 **Terminal（终端）**（如 Windows 的 CMD、PowerShell 或 Mac 的 Terminal）。它不是什么神秘的黑客工具，而是一种直接通过文字指令与操作系统对话的方式。相比于用鼠标点击图标，终端能更精确、更快速地执行复杂的任务。

### 排查 command not found

新手最容易崩溃的时刻，就是敲完命令回车后看到 `command not found`。这个报错其实有固定的排查思路：先检查命令拼写有没有空格或错误（`l s` 和 `ls` 是两回事），然后确认这个工具是不是已经装了（比如 `pnpm` 需要先安装才能用），再检查当前目录是不是在正确的项目文件夹里。如果命令本身没错也装了，那可能是 PATH 环境变量的问题——系统找不到工具的位置。最后还要注意系统差异，Windows 不支持某些 Unix 命令。建立这个排查思维比记忆具体错误信息更重要，因为以后还会遇到各种类似的"找不到东西"的报错。

### 开源代码包

环境有了，老师傅告诉你，现代软件开发很少从零开始写起。就像盖房子不需要自己烧砖一样，你可以直接使用全世界程序员贡献的代码——也就是**开源代码包**。React 帮你搞定界面，Axios 帮你搞定网络请求，Day.js 帮你处理时间，Zod 帮你处理数据验证……。这些现成的代码包能让你专注于业务逻辑，而不是重复造轮子。

### pnpm 包管理器

那么，怎么安装别人写好的代码包呢？你需要一个**包管理器**。Node.js 自带了一个叫 **npm**，但它下载速度慢，而且会把你的硬盘塞满重复的文件。有人开发了 **yarn**，但现在更推荐 **pnpm**。老师傅告诉你，一开始就使用 `pnpm`，它下载速度极快，而且通过巧妙的链接技术节省大量的硬盘空间。你学会了配置 pnpm 的国内镜像源，彻底解决了下载卡顿的问题。

你可能会问，npm 和 pnpm 到底有啥区别，值得专门切换吗？从实战数据来看，当你同时维护 10 个项目时，npm 会占用约 5GB 磁盘空间，而 pnpm 只需要约 2GB，且起新项目的适合安装更快。这个差异来源于它们的存储机制：npm 会为每个项目都存储一份完整的依赖副本，而 pnpm 让所有项目共享同一份依赖，只存储差异部分。在 AI 开发中，你会频繁创建新项目尝试不同方向，pnpm 能省下 2-3 倍的下载时间和 60% 的磁盘空间。这个小选择在初期不明显，但累积起来会显著影响开发体验。

### 文件夹命名

现在，你拥有了完整的现代化开发环境，可以处理任何 AI 生成的 Ts 代码了。老师傅特意叮嘱：**新建项目时，务必新建一个不含有中文、空格的文件夹**。这是因为许多底层的开发工具对非英文字符支持不佳，中文路径往往是各种离奇报错的根源。

### Localhost 与端口

代码都在本地了，但你完全不知道怎么把它跑起来。你试探性地把文件发给 AI，问它："我该怎么启动这个项目？"AI 告诉你，要先运行 `pnpm install` 安装依赖（把别人写好的积木搬回家），然后运行 `pnpm dev` 启动开发服务器。你照着敲了进去，屏幕上滚动了一堆看不懂的字符，最后停在了 `Ready in 2345ms`，下面还有一行绿色的字：`http://localhost:3000`。

你盯着这个地址，老师傅给你补了一课网络基础：**Localhost** 也就是 **127.0.0.1**，在网络世界里，这代表"你自己的电脑"。如果在互联网上，每个网站都有一个 IP 地址（如 `192.168.x.x`），那么 `127.0.0.1` 就是你电脑永远的"身份证号"，而 `localhost` 则是它的"名字"（域名）。

而在冒号后面的 **:3000** 则是**端口号（Port）**。如果把你的电脑比作一栋大楼，IP 是大楼的地址，那么端口就是具体的**房间号**。你的网页应用此刻正坐在 3000 号房间里，等待你的浏览器去敲门。

你激动地点开这个链接，网页真的出来了！不过，老师傅顺便提了一句，虽然现在的开发工具都很智能——如果你再开一个项目，它们通常会自动检测到 3000 房间有人了，然后自动顺延去 3001 房间——但在**生产环境**（也就是未来你要部署的服务器）里，规则是严苛的：**一个房间（端口）同时只能容纳一个程序**。如果你看到 `EADDRINUSE` 这样的红色报错，别慌，那只是意味着你想去的房间已经被占用了，通常让 AI 为你换一个启动的端口就行了。

### 环境变量

老师傅最后补充道：等你开始配置项目时，会接触到**环境变量**。这是一种存储配置信息的安全方式，比如数据库密码、API密钥等敏感信息，不应该直接写在代码里。**【详见第6章】**

### 版本控制意识

"还有一件事，"老师傅说，"从第一个项目开始，你就要建立**版本控制**的意识。代码管理的基础就是记录每次修改，方便随时回退。现在不用担心细节，**【详见第10章】**，但要记住这是好习惯。"
